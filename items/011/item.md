1 // item status
# Function templates
In C++ has *templates* which allow to implement generic functionality.
Let's assume we want to implement a non-member function `swap` which exchanges the contents of two objects of equal type `Widget`:
```pmans
struct Widget {
  int m;
  // what SMF are implicitly available?
};

void swap(Widget &a, Widget &b) { // takes two references, should swap 
  Widget tmp(std::move(a)); // save tmp. (1. move)
  a = std::move(b); // 2. move 
  b = std::move(tmp); // 3. move 
};
// requirement for widget here?
// move ctor (implicitly available?, yes)
// move assign (implicitly available? yes)
// ... copy versions of ctor and assign are also sufficient as a fallback

```
To make this swap functionality available for other types too, overloads could be used:
```pmans
struct Type1, Type2, Type3, Type4;
void swap(Type1 &a, Type1 &b) { ... };
void swap(Type2 &a, Type2 &b) { ... };
void swap(Type3 &a, Type3 &b) { ... }; 
void swap(Type4 &a, Type4 &b) { ... };
void swap(Type1 &a, Type4 &b) { ... }; // (1)
// does this make sense? two different types? might make sense, depends on types
swap(objA, objB); // overload resolution selects from your set of functions
```
> Is the "overload approach" good practice if the number of types to be supported is large?
> - duplication is bad: yes
> - if we need to optimize for special cases (types): then this overloading is a good idea
> - if a set of types you want to support needs exactly the same implementation then a template is a good idea
> - if a set of types each needs special treatment: work with overloads

If the implementation of `swap` does not depend on the type of the parameters, e.g., if the implementation for all above types looks like this
```pmans
/*f5*/ using /*b1*/ T = Type1; // only changing this type alias for Type2, Type3, Type4
void swap(/*b2*/ T& a, /*b2*/ T& b) {
  /*b1*/ T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}; 
```
implementing `swap` as a *function template* is advantageous and looks like this:
```pmans
/*f*/ template<typename /*x*/ /*b1*/ T/*f1*/ > // template function with a "type template parameter" 'T' 
void swap(/*b2*/ T& a, /*b2*/ T& b) {
  /*b1*/ T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}; 
```
> What are the required "prerequisites" for type `T` to be "compatible" with this function template?
 > - move-constructable 
> - move-assignable 
 > - is supporting only the copy version also OK? yes, if move is not present, copy is used automatically: rvalues can bind to the const lvalue references of copy-ctor and move-assign 

The definition of a template (function) is literally a template for the compiler:
- If the templated function **is not selected** to be used (anywhere in the translation unit), no code is generated for the (not selected) function.
- If the templated function **is selected** to be used, code is generated by the compiler (*instantiation*) - potentially multiple times for different types - according to the template definition.


## Template argument determination
In order to instantiate (or try to instantiate) any template, all arguments for the template parameters must be known to the compiler. 
There are three mechanism which lead to the determination of function template arguments (precedence in this order):
- explicitly specifying the arguments 
```pmans
  NotAWidget a{1};
  Widget b{2};
  swap/*b*/ <Widget> /*x*/(a, b); // instantiates /*f*/ void swap<Widget>(Widget&, Widget&) /*x*/
```
- deduction from function arguments 
```pmans
  /*f6*/ Widget a{1};
  /*f6*/ Widget b{2};
  swap(/*b1*/ a, /*b1*/ b);         // instantiates /*f*/ void swap<Widget>(Widget&, Widget&) /*x*/
```
- default arguments for template parameters are defined 
```pmans
  template <typename /*b1*/ T, typename /*b1*/ D = /*f*/ decltype(T().m) /*x*/> 
  void swap(/*b3*/ T& a, /*b3*/ T& b) {
    /*b1*/ D tmp(std::move(a.m));
    a.m = std::move(b.m);
    b.m = std::move(tmp);
  };
  // usage
  /*f6*/ Widget a{1};
  /*f6*/ Widget b{2};  
  swap<Widget>(/*b1*/ a, /*b1*/ b);   // instantiates /*f*/ void swap<Widget,int>(Widget&, Widget&) /*x*/ 
```

> Which additional requirement for `Widget` (for successful instantiation) is introduced in the last snippet above?
<!-- > - existence of a `m` member which is move-assignable and move-constructable -->

## Function template argument deduction
Let's look closer at the rules for deducing template arguments from function arguments. 
We will consider a function template with a single argument of a form similar to this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*b5*/ AUTO arg) {};
```
The type of the function parameter is marked in red and the template parameter is is marked in bold blue.
A type is deduced for both, influenced by the expression passed as an argument:
```pmans
func(/*b4*/ expr);
```
The rules for template argument deduction are also applied during `auto` type deduction, i.e., the following snippet will use the same mechanism to deduce the type for `arg` from the expression `expr` as the function template above. 
```pmans
/*b5*/ auto arg = (/*b4*/ expr);
```
> Is this really exactly the same mechanism?
> - yes, but one exception concerning `std::initializer_list`. See [auto.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/auto.cpp) 

In the following we will consider these four different scenarios for deduction:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO arg) {}; // pass-by-value
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO/*b1*/ & arg) {}; // pass-by-reference
template <typename /*f4*/ AUTO> 
void func(/*b5*/ const /*f4*/ AUTO/*b1*/ & arg) {}; // pass-by-reference-to-const
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO/*b2*/ && arg) {}; // pass-by-forwarding-references
```

### Pass-by-value
If the function parameter is passed by-value the function template looks like this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO arg) {
  arg.m = 5; // would not work if const was not dropped 
};
```
The following snippet illustrates the deduction for different value categories and types:
```pmans
Widget lval{1};    
Widget &lref = lval;   
const Widget &clref = lval;  
Widget *ptr = &lval; 
const Widget *cptr = &lval; 
const Widget *const cptrc = &lval; 

func(lval);                 // (1) /*f*/ func<Widget>(Widget arg) /*x*/ for lvalue
func(lref);                 // (2) /*f*/ func<Widget>(Widget arg) /*x*/ for lvalue reference
func(clref);                // /*f*/ func<Widget>(Widget arg) /*x*/ for lvalue reference to const
func(Widget{});             // /*f*/ func<Widget>(Widget arg) /*x*/ for rvalue
func(std::move(lval));      // /*f*/ func<Widget>(Widget arg) /*x*/ for rvalue reference
func(std::move(clref));     // /*f*/ func<Widget>(Widget arg) /*x*/ for rvalue reference to const    
func(ptr);                  // /*f*/ func<Widget *>(Widget *arg) /*x*/ for ptr
func(cptr);                 // /*f*/ func<const Widget *>(const Widget *arg) /*x*/ for ptr to const // why const not dropped here?
func(cptrc);                // /*f*/ func<const Widget *>(const Widget *arg) /*x*/ for const ptr to const
```
To summarize for a pass-by-value function parameter: 
- `const` is dropped 
- reference-ness is not reflected in the deduced types (makes sense, its a copy not related to the reference)
- for pointers const access to the pointee ist not dropped
- the two deduced types (template parameter type and function paramter type) are identical

> Do these rules for pass-by-value make sense?
> - const-ness is not preserved(dropped): this makes sense, as everything is pass-by-value
> - reference-ness is not preserved: makes sense, we asked for a copy
> - pointers: passing a pointer-to-const preserves the constness; this is what is expected from the caller site.
> - See [deduction_val.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/deduction_val.cpp) for the full example code 


### Pass-by-reference
If the function parameter is passed by-reference the function template looks like this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO/*b1*/ & arg) {}; // can we pass temporary obejct?
```
The following snippet again illustrates the deduction for different value categories and types:
```pmans
Widget lval{1};    
Widget &lref = lval;   
const Widget &clref = lval;  
Widget *ptr = &lval; 
const Widget *cptr = &lval; 
const Widget *const ptrc = &lval; 
func(lval);                 // /*f*/ func<Widget>(Widget &arg) /*x*/ for lvalue
func(lref);                 // /*f*/ func<Widget>(Widget &arg) /*x*/ for lvalue reference
func(clref);                // /*f*/ func<const Widget>(const Widget &arg) /*x*/ for lvalue reference to const   
func(ptr);                  // /*f*/ func<Widget *>(Widget *&arg) /*x*/ for ptr
func(cptr);                 // /*f*/ func<const Widget *>(const Widget *&arg) /*x*/ for ptr to const
func(cptrc);                // /*f*/ func<const Widget *const>(const Widget *const &arg) /*x*/ for const ptr to const
func(Widget{}); // passing rvalue // func<Widget>(Widget& arg)
//human compiler:
// 1. there is a an rvalue as argument
// 2. try to "paste" of expr into template type
// 3. cannot bind rvalue to lvalue reference
```
> Use case for passing "a reference to a pointer"?
> - e.g., write a function which might reallocate a dynamic resource available through the pointer

To summarize for a pass-by-reference function parameter: 
- `const`-ness is preserved in both deduced types
- if `expr` is a reference type or not does not influence the deduction
- function parameter type is always a lvalue reference
- the template parameter is never of reference type


> Do these pass-by-ref rules make sense?
> - const-ness is preserved: this is what is expected when passing a const or const reference
> - const-ness is also preserved in the template parameter type: this allows to specialize the implementation if a function parameter is const
> - the function parameter type is always a lvalue reference: this is what we asked for
> - See [deduction_lref.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/deduction_lref.cpp) for the full sources of the example

### Pass-by-reference-to-const 
If the function parameter is passed by a lvalue-reference to const, the function template looks like this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*b5*/ const /*f4*/ AUTO/*b1*/ & arg) {};
```
And again, following snippet illustrates the deduction for different value categories and types:
```pmans
Widget lval{1};    
Widget &lref = lval;   
const Widget &clref = lval;  
Widget *ptr = &lval; 
const Widget *cptr = &lval; 
const Widget *const cptrc = &lval; 
func(lval);                 // /*f*/ func<Widget>(const Widget &arg) /*x*/ for lvalue/reference
func(clref);                // /*f*/ func<Widget>(const Widget &arg) /*x*/ for lvalue/reference to const   
func(Widget{});             // /*f*/ func<Widget>(const Widget &arg) /*x*/ for rvalue/reference  
func(ptr);                  // /*f*/ func<Widget *>(Widget *const &arg) /*x*/ for ptr
func(cptr);                 // /*f*/ func<const Widget *>(const Widget *const &arg) /*x*/ for ptr to const
func(cptrc);                // /*f*/ func<const Widget *>(const Widget *const &arg) /*x*/ for const ptr to const
```

Small insert on *west-const* and *east-const*:
```pmans
const double dd = 5; // (1a) OK, west-const
double const dd = 5; // (1b) OK too! east-const
const double* dd = ...; // (2a) const is left associative, if "there is something"
double const* dd = ...; // (2b) equivalent
const double* const dd = ...; // (3a) second const looks to the left and applies to pointer "only"
double const* const dd = ...; // (3b) equivalent 
(double const)(* const) dd = ...; // (3c) with parentheses  indicating groups (does not compile) 
```

To summarize for a pass-by-reference-to-const function parameter: 
- the "forced" `const`-ness is not reflected in the type of the template parameter
- function parameter type is always a lvalue reference
- the template parameter is never of reference type

> Do these rules for pass-by-const-ref make sense?
> - "original" const-ness is not preserved: this is OK, everything is passed as const anyway
> - "original" reference type is lost: this is what we asked for: to always bind to an lvalue reference to const
> - pointer: const is "forced" for the pointer type itself,e.g., `Widget *const`: this is expected; see below snippet for a syntax which reveals this:
>```pmans
>  Widget a{1};
>  using Pointer = Widget *; // equivalent: Widget *
>  using ConstPointer = const Pointer; // equivalent: Widget *const
>  using PointerToConst = const Widget *; // equivalent: const Widget *
>  using ConstPointerToConst = const PointerToConst; // equivalent: const Widget *const
>```
> - See [deduction_clref.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/deduction_clref.cpp) for the full sources of the example


Note: the same deduction rules apply analogously when using a const rvalue-reference which look like this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*b*/ const AUTO&& /*x*/ arg) {};
```
Then simply all occurrences of `&` in the deduced types are replaced with `&&`.

### Pass-by-forwarding-reference
In the semantic embedding of a function template the syntax for a non-const rvalue reference has a special meaning:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO/*b2*/ && arg) {};
template <typename  Widget &> 
void func( Widget & arg) {}; // reference collapsing: single lvalue -> lvalue ref
``` 
Here `&&` denotes a so-called *forwarding reference* (or also *universal reference*) with special deduction rules.
The following snippet illustrates the deduction when using a forwarding reference:
```pmans
Widget lval{1};    
Widget &lref = lval;   
const Widget &clref = lval;  
Widget *ptr = &lval; 
const Widget *cptr = &lval; 
const Widget *const cptrc = &lval; 
func(lval);                 // (1) /*f*/ func<Widget &>(Widget &arg) /*x*/ for lvalue
func(lref);                 // /*f*/ func<Widget &>(Widget &arg) /*x*/ for lvalue reference
func(clref);                // /*f*/ func<const Widget &>(const Widget & arg) /*x*/ for lvalue reference to const
func(Widget{});             // /*f*/ func<Widget>(Widget &&arg) /*x*/ for rvalue
func(std::move(lval));      // /*f*/ func<Widget>(Widget &&arg) /*x*/ for rvalue reference
func(std::move(clref));     // /*f*/ func<const Widget>(const Widget &&arg) /*x*/ for rvalue reference to const    
func(ptr);                  // /*f*/ func<Widget *&>(Widget *&arg) /*x*/ for ptr
func(cptr);                 // /*f*/ func<const Widget *&>(const Widget *&arg) /*x*/ for ptr to const
func(cptrc);                // /*f*/ func<const Widget *const &>(const Widget *const &arg) /*x*/ for const ptr to const
```
To summarize when using a forwarding reference as function parameter: 
- the const-ness and value-ness of the expression passed to the function are fully preserved in the type of the function parameter
- the template parameter is a reference type if the expression was an lvalue; for rvalue it is non-reference type

> Do these rules for forwarding-refs make sense?
> - the rules aim to achieve a specific goal: to preserve the value category and const-ness of the originally passed expression (to be able to forward it later): this is achieved
> - the template parameter is non-reference for rvalues: this is OK (instead of being of rvalue reference) as it has no effect on reference collapsing (which applied during forwarding)
> - See [deduction_fref.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/deduction_fref.cpp) for the full sources of the example


```pmans
void func(Widget&& arg); // this is also not a forwarding ref! (no template)
```

Note:
This preservation of the "original" value category and const-ness in the type of the function parameters sets the stage for "perfect forwarding" of parameters to nested functions. To achieve this, additionally the "reference collapsing rules" and `std::forward` (which makes use of these rules) are required (see also the end of [Item006](https://cppitems.github.io/#/item/006) where we already briefly mentioned perfect forwarding in the context of `auto` type deduction). 

## Template parameter pack 
C++ allows to specify a *template parameter pack* (e.g., `typename ...ARGS`) as template parameter which can be mapped to a *function parameter pack* (e.g., `func(ARGS&&...args)`).
This allows to construct function templates accepting a variable number of arguments:
```pmans
template<typename .../*b4*/ ARGS> // named template parameter pack
void function(/*b4*/ ARGS... /*f4*/ args) { // function parameter pack
  ... // how to access/deal with /*f4*/ args here?
}
```
Let's look at some examples to illustrate some use cases using *fold expressions*:
```pmans
template <typename... /*b4*/ ARGS> auto sum_args(/*b4*/ ARGS &&... /*f4*/ args) {
  return (0 + ... + /*f4*/ args); // sums all args, initial value '0'
};
```
```pmans
template <typename... /*b4*/ ARGS> auto print_args(/*b4*/ ARGS &&... args) {
  ((std::cout << args << ','), ..., (std::cout << std::endl)); // prints all args
};
```
Can we also use this to wrap a function?

```pmans
template <typename... /*b4*/ ARGS> auto forward_args(/*b4*/ ARGS &&... /*f4*/ args) {
  return func(/*f4*/ args...); // passes all args to 'func' in same order
};
```
> Why is the above snippet not "perfect forwarding"?
>```pmans
>template <typename... /*b4*/ ARGS> auto perfect_forward_args(/*b4*/ ARGS &&... >/*f4*/ args) {
>  return func(std::forward</*b4*/ ARGS>(/*f4*/ args)...);
>};
>```


Parameter pack can also be combine with "regular" template parameters. Below this is used to build a "perfect" function wrapper:
```pmans
template <typename /*b4*/ FUNC, typename... /*b4*/ ARGS>
auto perfect_function_wrapper(/*b4*/ FUNC &&/*f8*/ callable, /*b4*/ ARGS &&... /*f4*/ args) {
    // increment call count
  return /*f8*/ callable(std::forward</*b4*/ ARGS>(/*f4*/ args)...); // forward makes rvalue references rvalues
};
// requirements for 'callable':
// operator(...) 
// arguments have to match to the ones provided in pack
```
> - See [tppack.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/tppack.cpp) for the full sources an example

___
lecture on November 11 procees here
___

## Template argument substitution
Above we considered *instantiation* as one step. 
Looking closer, *instantiation* is is separated in two stages:
- first, the template function arguments are determined (in one of the ways described above),
- then, all occurrences of these template parameters are *substituted* (replaced) with the respective arguments

> Can a argument substitution fail? Are there different types of failure? 
<!-- 
> - yes can fail: example: type does not support requirements

> - yes, depends "where" an error occurs
-->

Let's consider two examples showcasing the effect of errors occurring from the evaluation of
- expressions with "direct influence" on the function type and the template parameters, and
- the remainder of expressions (i.e., the "major part of the function body")

### Substitution failure **is** an error 
In the following snippet a non-existing nested type of `Widget` is used for a type alias inside the body of the function template: 
```pmans
struct Widget { int m; };

template <typename T> void swap(T &a, T &b) {
  /*b*/ using D = typename T::nonexisting; /*x*/ // (1)
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
};
// usage
Widget a{1};
Widget b{2};
swap(a, b); // (2) error pointing to line (1)
```
As expected, this leads to an error (compilation fails) which looks something like this:
```
failure1.cpp:9:25: error: no type named 'notexisting' in 'Widget'
  using D = typename T::nonexisting;
            ~~~~~~~~~~~~^~~~~~~~~~~
note: in instantiation of function template specialization 'swap<Widget>' requested here
  swap(a, b);
  ^            
```
> - See [failure1.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/failure1.cpp) for the full sources of the example

### **S**ubstitution **f**ailure **i**s **n**ot **a**n **e**rror 
Keeping everything the same as above but removing the type alias in the function body and instead introducing a second type template parameter `D` looks like this:
```pmans
struct Widget { int m; };

template <typename T, /*b*/ typename D = typename T::nonexisting /*x*/>
void swap(T &a, T &b) {
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
};
// usage
Widget a{1};
Widget b{2};
swap(a, b); // error: no match
```
As expected, this template still cannot be instantiated as underlying error is identical: `Widget::nonexisting` does not exist. 
But the error reported by the compiler is different:
```
failure2.cpp:17:3: error: no matching function for call to 'swap'
  swap(a, b);
  ^~~~
note: candidate template ignored: 
substitution failure [with T = Widget]: 
no type named 'nonexisting' in 'Widget'
void swap(T &a, T &b) {
```
This message reveals the effect of a substitution error in expressions with "direct influence" on the function type and the template parameters: the error does not lead to a failed compilation but "silently" discards the function template. 
If we extend the example by adding matching function, compilation succeeds.

> - See [failure2.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/failure2.cpp) for the full sources of the example

Note: This *SFINAE* property of the substitution mechanism  is used (also/primarily in the stdlib) to guide the selection of templates based on properties of determined template parameters.


# Links
- Function template https://en.cppreference.com/w/cpp/language/function_template
- Template argument deduction https://en.cppreference.com/w/cpp/language/template_argument_deduction
- Perfect forwarding https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c
- Scott Meyers, Effective Modern C++ (Items 1. and 2.) 
- Cppcon2020, Templates 1/2 https://www.youtube.com/watch?v=VNJ4wiuxJM4
- Cppcon2020, Templates 2/2 https://www.youtube.com/watch?v=0dtjDTEE0hQ
- SFINAE https://en.cppreference.com/w/cpp/language/sfinae
- Parameter pack: https://en.cppreference.com/w/cpp/language/parameter_pack
