1 // item status
# Function templates
In C++ has *templates* which allow to implement generic functionality.
Let's assume we want to implement a non-member function `swap` which exchanges the contents of two objects of equal type `Widget`:
```pmans
struct Widget {
  int m;
};

void swap(Widget &a, Widget &b) {
  Widget tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
};
```
To make this swap functionality available for other types too, overloads could be used:
```pmans
struct Type1, Type2, Type3, Type4;
void swap(Type1 &a, Type1 &b) { ... };
void swap(Type2 &a, Type2 &b) { ... };
void swap(Type3 &a, Type3 &b) { ... };
void swap(Type4 &a, Type4 &b) { ... };
```
> Is the "overload approach" good practice if the number of types to be supported is large?

If the implementation of `swap` does not depend on the type of the parameters, e.g., if the implementation for all above types looks like this
```pmans
/*f5*/ using /*b1*/ T = Type1; // only changing this type alias for Type2, Type3, Type4
void swap(/*b2*/ T& a, /*b2*/ T& b) {
  /*b1*/ T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}; 
```
implementing `swap` as a *function template* is advantageous and looks like this:
```pmans
/*f*/ template<typename /*x*/ /*b1*/ T/*f1*/  = Type1> // template function with a "type template parameter" 'T' 
void swap(/*b2*/ T& a, /*b2*/ T& b) {
  /*b1*/ T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}; 
```
> What are the required "prerequisites" for type `T` to be "compatible" with this function template?

The definition of a template (function) is literally a template for the compiler:
- If the templated function **is not selected** to be used (anywhere in the translation unit), no code is generated for the (not selected) function.
- If the templated function **is selected** to be used, code is generated by the compiler (*instantiation*) - potentially multiple times for different types - according to the template definition.


## Template argument determination
In order to instantiate (or try to instantiate) any template, all arguments for the template parameters must be known to the compiler. 
There are three mechanism which lead to the determination of function template arguments (precedence in this order):
- explicitly specifying the arguments 
```pmans
  Widget a{1};
  Widget b{2};
  swap/*b*/ <Widget> /*x*/(a, b); // instantiates /*f*/ void swap<Widget>(Widget&, Widget&) /*x*/
```
- deduction from function arguments 
```pmans
  /*f6*/ Widget a{1};
  /*f6*/ Widget b{2};
  swap(/*b1*/ a, /*b1*/ b);         // instantiates /*f*/ void swap<Widget>(Widget&, Widget&) /*x*/
```
- default arguments for template parameters are defined 
```pmans
  template <typename /*b1*/ T, typename /*b1*/ D = /*f*/ decltype(T().m) /*x*/> 
  void swap(/*b3*/ T& a, /*b3*/ T& b) {
    /*b1*/ D tmp(std::move(a.m));
    a.m = std::move(b.m);
    b.m = std::move(tmp);
  };
  // usage
  /*f6*/ Widget a{1};
  /*f6*/ Widget b{2};  
  swap<Widget>(/*b1*/ a, /*b1*/ b);   // instantiates /*f*/ void swap<Widget,int>(Widget&, Widget&) /*x*/ 
```

> Which additional requirement for `Widget` (for successful instantiation) is introduced in the last snippet above?

## Function template argument deduction
Let's look closer at the rules for deducing template arguments from function arguments. 
We will consider a function template with a single argument of a form similar to this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*b5*/ AUTO arg) {};
```
The type of the function parameter is marked in red and the template parameter is is marked in bold blue.
A type is deduced for both, influenced by the expression passed as an argument:
```pmans
func(/*b4*/ expr);
```
The rules for template argument deduction are also applied during `auto` type deduction, i.e., the following snippet will use the same mechanism to deduce the type for `arg` from the expression `expr` as the function template above. 
```pmans
/*b5*/ auto arg = (/*b4*/ expr);
```
> Is this really exactly the same mechanism?


In the following we will consider these four different scenarios for deduction:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO arg) {}; // pass-by-value
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO/*b1*/ & arg) {}; // pass-by-reference
template <typename /*f4*/ AUTO> 
void func(/*b5*/ const /*f4*/ AUTO/*b1*/ & arg) {}; // pass-by-reference-to-const
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO/*b2*/ && arg) {}; // pass-by-forwarding-references
```

### Pass-by-value
If the function parameter is passed by-value the function template looks like this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO arg) {};
```
The following snippet illustrates the deduction for different value categories and types:
```pmans
Widget lval{1};    
Widget &lref = lval;   
const Widget &clref = lval;  
Widget *ptr = &lval; 
const Widget *cptr = &lval; 
const Widget *const cptrc = &lval; 
func(lval);                 // /*f*/ func<Widget>(Widget arg) /*x*/ for lvalue
func(lref);                 // /*f*/ func<Widget>(Widget arg) /*x*/ for lvalue reference
func(clref);                // /*f*/ func<Widget>(Widget arg) /*x*/ for lvalue reference to const
func(Widget{});             // /*f*/ func<Widget>(Widget arg) /*x*/ for rvalue
func(std::move(lval));      // /*f*/ func<Widget>(Widget arg) /*x*/ for rvalue reference
func(std::move(clref));     // /*f*/ func<Widget>(Widget arg) /*x*/ for rvalue reference to const    
func(ptr);                  // /*f*/ func<Widget *>(Widget *arg) /*x*/ for ptr
func(cptr);                 // /*f*/ func<const Widget *>(const Widget *arg) /*x*/ for ptr to const
func(cptrc);                // /*f*/ func<const Widget *>(const Widget *arg) /*x*/ for const ptr to const
```
To summarize for a pass-by-value function parameter: 
- `const` is dropped 
- reference-ness is not reflected in the deduced types (makes sense, its a copy not related to the reference)
- for pointers const access to the pointee ist not dropped
- the two deduced types (template parameter type and function paramter type) are identical

> Do these rules for pass-by-value make sense?

### Pass-by-reference
If the function parameter is passed by-reference the function template looks like this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO/*b1*/ & arg) {};
```
The following snippet again illustrates the deduction for different value categories and types:
```pmans
Widget lval{1};    
Widget &lref = lval;   
const Widget &clref = lval;  
Widget *ptr = &lval; 
const Widget *cptr = &lval; 
const Widget *const ptrc = &lval; 
func(lval);                 // /*f*/ func<Widget>(Widget &arg) /*x*/ for lvalue
func(lref);                 // /*f*/ func<Widget>(Widget &arg) /*x*/ for lvalue reference
func(clref);                // /*f*/ func<const Widget>(const Widget &arg) /*x*/ for lvalue reference to const   
func(ptr);                  // /*f*/ func<Widget *>(Widget *&arg) /*x*/ for ptr
func(cptr);                 // /*f*/ func<const Widget *>(const Widget *&arg) /*x*/ for ptr to const
func(cptrc);                // /*f*/ func<const Widget *const>(const Widget *const &arg) /*x*/ for const ptr to const
```
To summarize for a pass-by-reference function parameter: 
- `const`-ness is preserved in both deduced types
- if `expr` is a reference type or not does not influence the deduction
- function parameter type is always a lvalue reference
- the template parameter is never of reference type


> Do these pass-by-ref rules make sense?


### Pass-by-reference-to-const 
If the function parameter is passed by a lvalue-reference to const, the function template looks like this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*b5*/ const /*f4*/ AUTO/*b1*/ & arg) {};
```
And again, following snippet illustrates the deduction for different value categories and types:
```pmans
Widget lval{1};    
Widget &lref = lval;   
const Widget &clref = lval;  
Widget *ptr = &lval; 
const Widget *cptr = &lval; 
const Widget *const cptrc = &lval; 
func(lval);                 // /*f*/ func<Widget>(const Widget &arg) /*x*/ for lvalue/reference
func(clref);                // /*f*/ func<Widget>(const Widget &arg) /*x*/ for lvalue/reference to const   
func(Widget{});             // /*f*/ func<Widget>(const Widget &arg) /*x*/ for rvalue/reference  
func(ptr);                  // /*f*/ func<Widget *>(Widget *const &arg) /*x*/ for ptr
func(cptr);                 // /*f*/ func<const Widget *>(const Widget *const &arg) /*x*/ for ptr to const
func(cptrc);                // /*f*/ func<const Widget *>(const Widget *const &arg) /*x*/ for const ptr to const
```
To summarize for a pass-by-reference-to-const function parameter: 
- the "forced" `const`-ness is not reflected in the type of the template parameter
- function parameter type is always a lvalue reference
- the template parameter is never of reference type

> Do these rules for pass-by-const-ref make sense?

Note: the same deduction rules apply analogously when using a const rvalue-reference which look like this:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*b*/ const AUTO&& /*x*/ arg) {};
```
Then simply all occurrences of `&` in the deduced types are replaced with `&&`.

### Pass-by-forwarding-reference
In the semantic embedding of a function template the syntax for a non-const rvalue reference has a special meaning:
```pmans
template <typename /*f4*/ AUTO> 
void func(/*f4*/ AUTO/*b2*/ && arg) {};
``` 
Here `&&` denotes a so-called *forwarding reference* (or also *universal reference*) with special deduction rules.
The following snippet illustrates the deduction when using a forwarding reference:
```pmans
Widget lval{1};    
Widget &lref = lval;   
const Widget &clref = lval;  
Widget *ptr = &lval; 
const Widget *cptr = &lval; 
const Widget *const cptrc = &lval; 
func(lval);                 // /*f*/ func<Widget &>(Widget &arg) /*x*/ for lvalue
func(lref);                 // /*f*/ func<Widget &>(Widget &arg) /*x*/ for lvalue reference
func(clref);                // /*f*/ func<const Widget &>(const Widget & arg) /*x*/ for lvalue reference to const
func(Widget{});             // /*f*/ func<Widget>(Widget &&arg) /*x*/ for rvalue
func(std::move(lval));      // /*f*/ func<Widget>(Widget &&arg) /*x*/ for rvalue reference
func(std::move(clref));     // /*f*/ func<const Widget>(const Widget &&arg) /*x*/ for rvalue reference to const    
func(ptr);                  // /*f*/ func<Widget *&>(Widget *&arg) /*x*/ for ptr
func(cptr);                 // /*f*/ func<const Widget *&>(const Widget *&arg) /*x*/ for ptr to const
func(cptrc);                // /*f*/ func<const Widget *const &>(const Widget *const &arg) /*x*/ for const ptr to const
```
To summarize when using a forwarding reference as function parameter: 
- the const-ness and value-ness of the expression passed to the function are fully preserved in the type of the function parameter
- the template parameter is a reference type if the expression was an lvalue; for rvalue it is non-reference type

> Do these rules for forwarding-refs make sense?

Note:
This preservation of the "original" value category and const-ness in the type of the function parameters sets the stage for "perfect forwarding" of parameters to nested functions. To achieve this, additionally the "reference collapsing rules" and `std::forward` (which makes use of these rules) are required (see also the end of [Item006](https://cppitems.github.io/#/item/006) where we already briefly mentioned perfect forwarding in the context of `auto` type deduction). 

## Template parameter pack 
C++ allows to specify a *template parameter pack* (e.g., `typename ...ARGS`) as template parameter which can be mapped to a *function parameter pack* (e.g., `func(ARGS&&...args)`).
This allows to construct function templates accepting a variable number of arguments:
```pmans
template<typename .../*b4*/ ARGS> // named template parameter pack
void function(/*b4*/ ARGS... /*f4*/ args) { // function parameter pack
  ... // how to access/deal with /*f4*/ args here?
}
```
Let's look at some examples to illustrate some use cases using *fold expressions*:
```pmans
template <typename... /*b4*/ ARGS> auto sum_args(/*b4*/ ARGS &&... /*f4*/ args) {
  return (0 + ... + /*f4*/ args); // sums all args, initial value '0'
};
```
```pmans
template <typename... /*b4*/ ARGS> auto print_args(/*b4*/ ARGS &&... args) {
  ((std::cout << args << ','), ..., (std::cout << std::endl)); // prints all args
};
```
Can we also use this to wrap a function?

```pmans
template <typename... /*b4*/ ARGS> auto forward_args(/*b4*/ ARGS &&... /*f4*/ args) {
  return func(/*f4*/ args...); // passes all args to 'func' in same order
};
```
> Why is the above snippet not "perfect forwarding"?

Parameter pack can also be combine with "regular" template parameters. Below this is used to build a "perfect" function wrapper:
```pmans
template <typename /*b4*/ FUNC, typename... /*b4*/ ARGS>
auto perfect_function_wrapper(/*b4*/ FUNC &&/*f8*/ callable, /*b4*/ ARGS &&... /*f4*/ args) {
  return /*f8*/ callable(std::forward</*b4*/ ARGS>(/*f4*/ args)...);
};
```
> - See [tppack.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/tppack.cpp) for the full sources an example

## Template argument substitution
Above we considered *instantiation* as one step. 
Looking closer, *instantiation* is is separated in two stages:
- first, the template function arguments are determined (in one of the ways described above),
- then, all occurrences of these template parameters are *substituted* (replaced) with the respective arguments

> Can a argument substitution fail? Are there different types of failure? 

Let's consider two examples showcasing the effect of errors occurring from the evaluation of
- expressions with "direct influence" on the function type and the template parameters, and
- the remainder of expressions (i.e., the "major part of the function body")

### Substitution failure **is** an error 
In the following snippet a non-existing nested type of `Widget` is used for a type alias inside the body of the function template: 
```pmans
struct Widget { int m; };

template <typename T> void swap(T &a, T &b) {
  /*b*/ using D = typename T::nonexisting; /*x*/ // (1)
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
};
// usage
Widget a{1};
Widget b{2};
swap(a, b); // (2) error pointing to line (1)
```
As expected, this leads to an error (compilation fails) which looks something like this:
```
failure1.cpp:9:25: error: no type named 'notexisting' in 'Widget'
  using D = typename T::nonexisting;
            ~~~~~~~~~~~~^~~~~~~~~~~
note: in instantiation of function template specialization 'swap<Widget>' requested here
  swap(a, b);
  ^            
```
> - See [failure1.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/failure1.cpp) for the full sources of the example

### **S**ubstitution **f**ailure **i**s **n**ot **a**n **e**rror 
Keeping everything the same as above but removing the type alias in the function body and instead introducing a second type template parameter `D` looks like this:
```pmans
struct Widget { int m; };

template <typename T, /*b*/ typename D = typename T::nonexisting /*x*/>
void swap(T &a, T &b) {
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
};
// usage
Widget a{1};
Widget b{2};
swap(a, b); // error: no match
```
As expected, this template still cannot be instantiated as underlying error is identical: `Widget::nonexisting` does not exist. 
But the error reported by the compiler is different:
```
failure2.cpp:17:3: error: no matching function for call to 'swap'
  swap(a, b);
  ^~~~
note: candidate template ignored: 
substitution failure [with T = Widget]: 
no type named 'nonexisting' in 'Widget'
void swap(T &a, T &b) {
```
This message reveals the effect of a substitution error in expressions with "direct influence" on the function type and the template parameters: the error does not lead to a failed compilation but "silently" discards the function template. 
If we extend the example by adding matching function, compilation succeeds.

> - See [failure2.cpp](https://raw.githubusercontent.com/cppitems/cppitems/master/items/011/failure2.cpp) for the full sources of the example

Note: This *SFINAE* property of the substitution mechanism  is used (also/primarily in the stdlib) to guide the selection of templates based on properties of determined template parameters.


# Links
- Function template https://en.cppreference.com/w/cpp/language/function_template
- Template argument deduction https://en.cppreference.com/w/cpp/language/template_argument_deduction
- Perfect forwarding https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c
- Scott Meyers, Effective Modern C++ (Items 1. and 2.) 
- Cppcon2020, Templates 1/2 https://www.youtube.com/watch?v=VNJ4wiuxJM4
- Cppcon2020, Templates 2/2 https://www.youtube.com/watch?v=0dtjDTEE0hQ
- SFINAE https://en.cppreference.com/w/cpp/language/sfinae
- Parameter pack: https://en.cppreference.com/w/cpp/language/parameter_pack
